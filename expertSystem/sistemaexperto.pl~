%% Muestra mas contenidos de las listas 
:- set_prolog_flag(toplevel_print_options, [max_depth(100)]).

%% Permite predicdos dinamicos en la base de conocimiento, asi las caract pueden
%% ser assert al tiempo de ejecucion
:- dynamic baseDeConocimiento/1.
%% Load the knowledge base and questions database.
:- consult('kb').
:- consult('preguntas.pl').

%% Escribe una Fact en la base de conocimiento.
writeKBLine(Stream, Fact) :-
  write(Stream, 'kb('),
  write(Stream, Fact),
  write(Stream, ').'),
  write(Stream, '\n').

%% Escribe todas las Facts en el archivo de la base de conocimiento.
writeKB :-
  open('bc', write, Stream),
  forall(kb(Fact), writeKBLine(Stream, Fact)),
  close(Stream).

%% Regresa todas las Facts de la base de conocimiento actual
listFacts(List) :-
  findall(X, kb(X), List).

%% Toma la lista de Facts y las asserta para hacerlas activas en el programa actual
assertFacts([Fact]) :-
  assertz(Fact).
assertFacts([H|T]) :-
  assertz(H),
  assertFacts(T).

%% Carga todas las Facts y las asserta cuando el archivo es cargado
:- listFacts(List), assertFacts(List).

%% Aplica la conjuncion a cualquier predicado en la lista 
%%
%% Ejemplo: `hasProperties([foo, bar, baz], X).` es equivalente a 
%%          `foo(X), bar(X), baz(X).`
%%
%% Adaptado de:
%% http://stackoverflow.com/questions/10410082/list-of-predicates-in-prolog
hasProperties([], _).
hasProperties([P|Ps], X) :-
  call(P, X),
  hasProperties(Ps, X).

%% Collecta todos los resultado del hazProperty query en una lista 
allMatches(List, Out) :-
  findall(X, hasProperties(List, X), Out).

%% Escribe todos los string de la lista a la terminal en orden
writeLine(Line) :-
  (
    Line = []    -> true;
    Line = nl    -> nl;
    Line = [A|B] -> writeLine(A), writeLine(B);
    otherwise    -> write(Line)
  ).

%% Despliega al usuario una linea para insersion. Normalisa la respuesta para ser en minuscula
listen(Input) :-
  write('> '),
  read_line_to_codes(user_input, Codes),
  atom_codes(RawInput, Codes),
  downcase_atom(RawInput, Input).

%% Concatena todos los strings en la lista en un solo string de salida
concat(List, Output) :-
  (
    List = []    -> Output = '';
    List = [A|B] -> concat(B, Tail), string_concat(A, Tail, Output)
  ).

%% Actualiza la base de conocimiento para contener todas las Facts dadas en la lista
saveFacts([Pred], Actual) :-
  Pred =.. [Name, Val],
  NewPred =.. [Name, Val, Actual],
  assertz(kb(NewPred)).

saveFacts([H|T], Actual) :-
  saveFacts([H], Actual),
  saveFacts(T, Actual).

%% Intenta adivinar en lo que pensó el usuario
makeGuess(Guess, QuestionNum, ActiveList) :-
  writeLine([nl, 'Are you thinking of a ', Guess, '?', nl]),
  listen(Answer),
  (
    Answer = 'yes' -> onLose(QuestionNum, Guess);
    Answer = 'no' -> onWin(ActiveList)
  ).

%% Si un numero es menor a 1, la salida es reciproca a el, si no, da el mismo numero
flipRatio(InRatio, OutRatio) :-
  (
    InRatio < 1 -> OutRatio is 1 / InRatio;
    otherwise -> OutRatio is InRatio
  ).


%% Para una propiedad, calcula el radio entre el numero de entidades que  tienen la propiedad y el numero que no
calcRatio(Prop, Ratio) :-
  YesPred =.. [Prop, yes],
  NoPred =.. [Prop, no],
  findall(X, call(YesPred, X), Positives),
  findall(Y, call(NoPred, Y), Negatives),
  length(Positives, NumPos),
  length(Negatives, NumNeg),
  RawRatio is NumPos / NumNeg,
  flipRatio(RawRatio, Ratio).

%% Toma la pregunta de la lista de preguntas que dividen las actuales entidades en dos sets de tamaño similar
pickQuestion([[Pred, Question]], LowestRatio, Best, NewList) :-
  Best = [Pred, Question],
  NewList = [],
  calcRatio(Pred, LowestRatio).

pickQuestion([[Pred, Question]|Tail], LowestRatio, Best, List) :-
  calcRatio(Pred, Ratio),
  pickQuestion(Tail, NewLowestRatio, NewBest, NewList),
  (
    Ratio < NewLowestRatio ->
      LowestRatio = Ratio,
      List = Tail,
      Best = [Pred, Question];
    otherwise ->
      LowestRatio = NewLowestRatio,
      append(NewList, [[Pred, Question]], List),
      Best = NewBest
  ).

pickQuestion(List, Best, OutList) :-
  pickQuestion(List, _, Best, OutList).

%% Utilidad interna predicate usada por 'update'
update1(QuestionList, ActiveList, QuestionNum) :-
  NewNum is QuestionNum + 1,
  pickQuestion(QuestionList, PredQuestion, NewQuestionList),
  botLoop(PredQuestion, NewQuestionList, ActiveList, NewNum).

%% Maneja el caso cuando no hay preguntas restantes
update(_, _, [], ActiveList, _) :-
  writeLine(['No questions detected', nl]),
  onWin(ActiveList).

%% Actualiza la base de terminos actual, basado en la respuesta dada por el usuario
update(Answer, Pred, QuestionList, ActiveList, QuestionNum) :-
  NewPred =.. [Pred, Answer],
  append(ActiveList, [NewPred], NewActiveList),
  allMatches(NewActiveList, Results),
  length(Results, NumResults),
  (
    NumResults = 0 ->
      onWin(NewActiveList);

    NumResults = 1 ->
      [Guess] = Results,
      makeGuess(Guess, QuestionNum, NewActiveList);

    otherwise ->
      update1(QuestionList, NewActiveList, QuestionNum)
  ).

showHelp :-
  writeLine([
    'Prolog Twenty Questions Help', nl, nl,
    'yes: Tell the game that its question was correct.', nl,
    'no: Tell the game that its question was incorrect.', nl,
    'maybe: Tell the game you do not know the answer to its question.', nl,
    'help: Show this help message.', nl,
    'quit: Quit the game.', nl
  ]).

%% Llamado cuando el usuario sale del juego. Muestra un mensaje de despedida
onQuit :-
  writeLine(['Goodbye!', nl]),
  true.

%% Llamado cuando el usuario gana el juego. Pregunta al usuario por la cosa en la ue estaba pensando
%%, para guardarlo en la base de conocimiento y usarla para mejorar la ejecucion futura.
onWin(ActiveList) :-
  writeLine([nl, 'I\'m out of ideas, you win! What were you thinking of?', nl]),
  listen(Actual),
  writeLine([nl, 'Thanks, I\'ll remember about ', Actual, ' for next time!', nl]),
  saveFacts(ActiveList, Actual),
  writeKB,
  true.

%% Llamado cuando el sistema adivina correctamente
onLose(QuestionNum, Guess) :-
  writeLine([nl, 'I guessed that you were thinking of "', Guess, '" in ',
    QuestionNum, ' tries.', nl, 'Better luck next time.']),
  true.

%% Llamado cuando el usuario da una respuesta invalida. Muestra el mensaje informandolo de ello
onInvalidResponse(Response) :-
  writeLine(['"', Response, '" is not a valid response, please type "yes", "no" or "maybe".',
    nl, 'To quit the game, type "quit".', nl]).

%% Analiza la linea de entrada para realizar la accion apropiada
parse(Input, [Pred, Question], QuestionList, ActiveList, QuestionNum) :-
  (
    QuestionNum = 20 -> onWin(ActiveList);

    Input = 'quit' -> onQuit;
    Input = 'stop' -> onQuit;
    Input = 'exit' -> onQuit;

    Input = 'help' ->
      showHelp,
      botLoop([Pred, Question], QuestionList, ActiveList, QuestionNum);

    Input = 'yes' ->
      update(yes, Pred, QuestionList, ActiveList, QuestionNum);

    Input = 'no' ->
      update(no, Pred, QuestionList, ActiveList, QuestionNum);

    Input = 'maybe' ->
      update1(QuestionList, ActiveList, QuestionNum);

    otherwise ->
      onInvalidResponse(Input),
      botLoop([Pred, Question], QuestionList, ActiveList, QuestionNum)
  ).

%% Loop principal
botLoop([Pred, Question], QuestionList, ActiveList, QuestionNum) :-
  nl,
  writeLine(['Question ', QuestionNum, ': ', Question, nl]),
  listen(Input),
  parse(Input, [Pred, Question], QuestionList, ActiveList, QuestionNum).

%% Imprime el mensaje de bienvenida
welcomeMessage :-
  writeLine(['Welcome to Twenty Questions!', nl,
    'Think of a something for me to guess, then press enter.', nl]).

%% Comando de inicio para que el sistema inicie
bot :-
  welcomeMessage,
  read_line_to_codes(user_input, _),
  questions(QuestionList),
  pickQuestion(QuestionList, PredQuestion, NewQuestionList),
  botLoop(PredQuestion, NewQuestionList, [], 1).
